{"version":3,"sources":["img/test.jpg","routes/Home.js","api/face.js","routes/ImageInput.js","routes/VideoInput.js","routes/Train.js","utils/index.js","App.js","serviceWorker.js","index.js"],"names":["module","exports","Home","style","listStyleType","fontSize","to","Component","loadModels","a","MODEL_URL","process","faceapi","getFullFaceDescription","blob","inputSize","scoreThreshold","OPTION","useTinyModel","img","withFaceLandmarks","withFaceDescriptors","fullDesc","maxDescriptorDistance","createMatcher","faceProfile","members","Object","keys","console","log","labeledDescriptors","map","member","name","descriptors","descriptor","Float32Array","faceMatcher","testImg","require","JSON_PROFILE","INIT_STATE","imageURL","detections","match","ImageInput","props","componentWillMount","setState","handleImage","state","image","then","fd","detection","findBestMatch","handleFileChange","event","resetState","URL","createObjectURL","target","files","loading","this","drawBox","i","_H","box","height","_W","width","_X","_x","_Y","_y","key","position","border","borderColor","transform","backgroundColor","marginTop","color","_label","id","type","onChange","accept","src","alt","withRouter","VideoInput","UNSAFE_componentWillMount","setInputDevice","navigator","mediaDevices","enumerateDevices","devices","filter","device","kind","length","facingMode","exact","startCapture","interval","setInterval","capture","webcam","current","getScreenshot","React","createRef","clearInterval","videoConstraints","camera","transition","className","display","flexDirection","alignItems","audio","ref","screenshotFormat","images","hasDownload","progress","Train","Array","from","f","valid","url","_","isEmpty","alert","getDescriptors","getResult","forEach","push","setTimeout","exportObj","exportName","dataStr","encodeURIComponent","document","createElement","setAttribute","body","appendChild","click","remove","downloadObjectAsJson","datas","m","stringify","join","JSON","replace","formatDescriptors","htmlFor","value","e","onFileChange","multiple","onClick","runFaceTrain","completed","index","App","history","createBrowserHistory","basename","path","component","Boolean","window","location","hostname","ReactDOM","render","getElementById","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.4852c6ee.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/test.34e86f06.jpg\";","import React, { Component } from 'react';\nimport { Link } from 'react-router-dom';\n\nexport default class Home extends Component {\n  render() {\n    return (\n      <center>\n        <h2>Facial Recognition App</h2>\n        <ul style={{ listStyleType: 'none', fontSize: '20px' }}>\n          <li>\n            <Link to=\"/train\">Train Model</Link>\n          </li>\n          <li>\n            <Link to=\"/photo\">Photo Input</Link>\n          </li>\n          <li>\n            <Link to=\"/camera\">Video Camera</Link>\n          </li>\n        </ul>\n      </center>\n    );\n  }\n}\n","import * as faceapi from 'face-api.js';\n\n// Load models and weights\nexport async function loadModels() {\n  const MODEL_URL = process.env.PUBLIC_URL + '/models';\n  await faceapi.loadTinyFaceDetectorModel(MODEL_URL);\n  await faceapi.loadFaceLandmarkTinyModel(MODEL_URL);\n  await faceapi.loadFaceRecognitionModel(MODEL_URL);\n}\n\nexport async function getFullFaceDescription(blob, inputSize = 512) {\n  // tiny_face_detector options\n  let scoreThreshold = 0.5;\n  const OPTION = new faceapi.TinyFaceDetectorOptions({\n    inputSize,\n    scoreThreshold\n  });\n  const useTinyModel = true;\n\n  // fetch image to api\n  let img = await faceapi.fetchImage(blob);\n\n  // detect all faces and generate full description from image\n  // including landmark and descriptor of each face\n  let fullDesc = await faceapi\n    .detectAllFaces(img, OPTION)\n    .withFaceLandmarks(useTinyModel)\n    .withFaceDescriptors();\n  return fullDesc;\n}\n\nconst maxDescriptorDistance = 0.5;\nexport async function createMatcher(faceProfile) {\n  // Create labeled descriptors of member from profile\n  let members = Object.keys(faceProfile);\n  console.log(members);\n  let labeledDescriptors = members.map(\n    member =>\n      new faceapi.LabeledFaceDescriptors(\n        faceProfile[member].name,\n        faceProfile[member].descriptors.map(\n          descriptor => new Float32Array(descriptor)\n        )\n      )\n  );\n\n  // Create face matcher (maximum descriptor distance is 0.5)\n  let faceMatcher = new faceapi.FaceMatcher(\n    labeledDescriptors,\n    maxDescriptorDistance\n  );\n  return faceMatcher;\n}\n","import React, { Component } from 'react';\nimport { withRouter } from 'react-router-dom';\nimport { loadModels, getFullFaceDescription, createMatcher } from '../api/face';\n\n// Import image to test API\nconst testImg = require('../img/test.jpg');\n\n// Import face profile\nconst JSON_PROFILE = require('../descriptors/dataset.json');\n\n// Initial State\nconst INIT_STATE = {\n  imageURL: testImg,\n  fullDesc: null,\n  detections: null,\n  descriptors: null,\n  match: null\n};\n\nclass ImageInput extends Component {\n  constructor(props) {\n    super(props);\n    this.state = { ...INIT_STATE, faceMatcher: null };\n  }\n\n  componentWillMount = async () => {\n    await loadModels();\n    this.setState({ faceMatcher: await createMatcher(JSON_PROFILE) });\n    await this.handleImage(this.state.imageURL);\n  };\n\n  handleImage = async (image = this.state.imageURL) => {\n    await getFullFaceDescription(image).then(fullDesc => {\n      if (!!fullDesc) {\n        this.setState({\n          fullDesc,\n          detections: fullDesc.map(fd => fd.detection),\n          descriptors: fullDesc.map(fd => fd.descriptor)\n        });\n      }\n    });\n\n    if (!!this.state.descriptors && !!this.state.faceMatcher) {\n      let match = await this.state.descriptors.map(descriptor =>\n        this.state.faceMatcher.findBestMatch(descriptor)\n      );\n      this.setState({ match });\n    }\n  };\n\n  handleFileChange = async event => {\n    this.resetState();\n    await this.setState({\n      imageURL: URL.createObjectURL(event.target.files[0]),\n      loading: true\n    });\n    this.handleImage();\n  };\n\n  resetState = () => {\n    this.setState({ ...INIT_STATE });\n  };\n\n  render() {\n    const { imageURL, detections, match } = this.state;\n\n    let drawBox = null;\n    if (!!detections) {\n      drawBox = detections.map((detection, i) => {\n        let _H = detection.box.height;\n        let _W = detection.box.width;\n        let _X = detection.box._x;\n        let _Y = detection.box._y;\n        return (\n          <div key={i}>\n            <div\n              style={{\n                position: 'absolute',\n                border: 'solid',\n                borderColor: 'blue',\n                height: _H,\n                width: _W,\n                transform: `translate(${_X}px,${_Y}px)`\n              }}\n            >\n              {!!match ? (\n                <p\n                  style={{\n                    backgroundColor: 'blue',\n                    border: 'solid',\n                    borderColor: 'blue',\n                    width: _W,\n                    marginTop: 0,\n                    color: '#fff',\n                    transform: `translate(-3px,${_H}px)`\n                  }}\n                >\n                  {match[i]._label}\n                </p>\n              ) : null}\n            </div>\n          </div>\n        );\n      });\n    }\n\n    return (\n      <div>\n        <input\n          id=\"myFileUpload\"\n          type=\"file\"\n          onChange={this.handleFileChange}\n          accept=\".jpg, .jpeg, .png\"\n        />\n        <div style={{ position: 'relative' }}>\n          <div style={{ position: 'absolute' }}>\n            <img src={imageURL} alt=\"imageURL\" />\n          </div>\n          {!!drawBox ? drawBox : null}\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default withRouter(ImageInput);\n","import React, { Component } from 'react';\nimport { withRouter } from 'react-router-dom';\nimport Webcam from 'react-webcam';\nimport { loadModels, getFullFaceDescription, createMatcher } from '../api/face';\n\n// Import face profile\nconst JSON_PROFILE = require('../descriptors/dataset.json');\n\nconst WIDTH = 420;\nconst HEIGHT = 420;\nconst inputSize = 160;\n\nclass VideoInput extends Component {\n  constructor(props) {\n    super(props);\n    this.webcam = React.createRef();\n    this.state = {\n      fullDesc: null,\n      detections: null,\n      descriptors: null,\n      faceMatcher: null,\n      match: null,\n      facingMode: null\n    };\n  }\n\n  UNSAFE_componentWillMount = async () => {\n    await loadModels();\n    this.setState({ faceMatcher: await createMatcher(JSON_PROFILE) });\n    this.setInputDevice();\n  };\n\n  setInputDevice = () => {\n    navigator.mediaDevices.enumerateDevices().then(async devices => {\n      let inputDevice = await devices.filter(\n        device => device.kind === 'videoinput'\n      );\n      if (inputDevice.length < 2) {\n        await this.setState({\n          facingMode: 'user'\n        });\n      } else {\n        await this.setState({\n          facingMode: { exact: 'environment' }\n        });\n      }\n      this.startCapture();\n    });\n  };\n\n  startCapture = () => {\n    this.interval = setInterval(() => {\n      this.capture();\n    }, 100);\n  };\n\n  componentWillUnmount() {\n    clearInterval(this.interval);\n  }\n\n  capture = async () => {\n    if (!!this.webcam.current) {\n      await getFullFaceDescription(\n        this.webcam.current.getScreenshot(),\n        inputSize\n      ).then(fullDesc => {\n        if (!!fullDesc) {\n          this.setState({\n            detections: fullDesc.map(fd => fd.detection),\n            descriptors: fullDesc.map(fd => fd.descriptor)\n          });\n        }\n      });\n\n      if (!!this.state.descriptors && !!this.state.faceMatcher) {\n        let match = await this.state.descriptors.map(descriptor =>\n          this.state.faceMatcher.findBestMatch(descriptor)\n        );\n        this.setState({ match });\n      }\n    }\n  };\n\n  render() {\n    const { detections, match, facingMode } = this.state;\n    let videoConstraints = null;\n    let camera = '';\n    if (!!facingMode) {\n      videoConstraints = {\n        width: WIDTH,\n        height: HEIGHT,\n        facingMode: facingMode\n      };\n      if (facingMode === 'user') {\n        camera = 'Front';\n      } else {\n        camera = 'Back';\n      }\n    }\n\n    let drawBox = null;\n    if (!!detections) {\n      drawBox = detections.map((detection, i) => {\n        let _H = detection.box.height;\n        let _W = detection.box.width;\n        let _X = detection.box._x;\n        let _Y = detection.box._y;\n        return (\n          <div key={i}>\n            <div\n              style={{\n                position: 'absolute',\n                border: 'solid',\n                borderColor: 'blue',\n                height: _H,\n                width: _W,\n                transition: 'all .2s ease',\n                transform: `translate(${_X}px,${_Y}px)`\n              }}\n            >\n              {!!match && !!match[i] ? (\n                <p\n                  style={{\n                    backgroundColor: 'blue',\n                    border: 'solid',\n                    borderColor: 'blue',\n                    width: _W,\n                    marginTop: 0,\n                    color: '#fff',\n                    transition: 'all .2s ease',\n                    transform: `translate(-3px,${_H}px)`\n                  }}\n                >\n                  {match[i]._label}\n                </p>\n              ) : null}\n            </div>\n          </div>\n        );\n      });\n    }\n\n    return (\n      <div\n        className=\"Camera\"\n        style={{\n          display: 'flex',\n          flexDirection: 'column',\n          alignItems: 'center'\n        }}\n      >\n        <p>Camera: {camera}</p>\n        <div\n          style={{\n            width: WIDTH,\n            height: HEIGHT\n          }}\n        >\n          <div style={{ position: 'relative', width: WIDTH }}>\n            {!!videoConstraints ? (\n              <div style={{ position: 'absolute' }}>\n                <Webcam\n                  audio={false}\n                  width={WIDTH}\n                  height={HEIGHT}\n                  ref={this.webcam}\n                  screenshotFormat=\"image/jpeg\"\n                  videoConstraints={videoConstraints}\n                />\n              </div>\n            ) : null}\n            {!!drawBox ? drawBox : null}\n          </div>\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default withRouter(VideoInput);\n","import React, { Component } from 'react';\nimport './Train.scss';\n\nimport { withRouter } from 'react-router-dom';\nimport Progress from 'react-progressbar';\nimport _ from 'lodash';\n\nimport { loadModels, getFullFaceDescription } from '../api/face';\nimport { formatDescriptors, downloadObjectAsJson } from '../utils';\n\n// Initial State\nconst INIT_STATE = {\n  name: 'Robby',\n  images: [],\n  descriptors: [],\n  hasDownload: false,\n  progress: 0,\n  loading: false,\n};\n\nclass Train extends Component {\n  constructor(props) {\n    super(props);\n    this.state = { ...INIT_STATE, faceMatcher: null };\n  }\n\n  async componentDidMount() {\n    await loadModels();\n  }\n\n  async onFileChange(files) {\n    this.resetState();\n    console.log('files', files);\n    const images = Array.from(files).map(f => {\n      return {\n        name: f.name,\n        valid: true,\n        url: URL.createObjectURL(f),\n      };\n    });\n    this.setState({ images });\n  };\n\n  resetState = () => {\n    this.setState({ ...INIT_STATE });\n  };\n\n  async runFaceTrain() {\n    if (_.isEmpty(this.state.name)) return alert('Please enter your name.');\n    if (_.isEmpty(this.state.images)) return alert('Please select images.');\n    console.log('Start to feature extraction');\n    await this.setState({ hasDownload: false, progress: 0, descriptors: [], loading: true });\n    await this.getDescriptors();\n    await this.getResult();\n  }\n\n  async getDescriptors() {\n    await this.state.images.forEach(async image => {\n      const fullDesc = await getFullFaceDescription(image.url);\n      console.log(image.name, fullDesc);\n      const descriptors = this.state.descriptors;\n      descriptors.push(fullDesc[0].descriptor);\n      this.setState({ descriptors });\n    });\n  }\n\n  getResult() {\n    if (this.state.descriptors.length === this.state.images.length && !this.state.hasDownload) {\n      this.setState({ hasDownload: true, progress: 100, loading: false });\n      console.log('descriptors', this.state.descriptors);\n      downloadObjectAsJson(formatDescriptors(this.state.name, this.state.descriptors), 'dataset');\n    } else {\n      let progress = this.state.progress > 90 ? 90 : this.state.progress + 30;\n      progress = progress > 100 ? 100 : progress;\n      setTimeout(() => {\n        console.log(progress);\n        this.setState({ progress }, () => this.getResult())\n      }, 1000);\n    }\n  }\n\n  render() {\n    return (\n      <div id='train' className={this.state.loading ? 'loading' : ''}>\n        <header>圖片特徵提取 <small>Feature Extraction</small></header>\n        <div className='train-tools'>\n          <label htmlFor='uname'>Name:</label>\n          <input className='tool-name' id='uname' type='text' value={this.state.name} onChange={(e) => this.setState({ name: e.target.value })} />\n          <input\n            className='tool-file'\n            id=\"myFileUpload\"\n            type=\"file\"\n            onChange={(e) => this.onFileChange(e.target.files)}\n            accept=\".jpg, .jpeg, .png\"\n            multiple={true}\n          />\n          <button className='tool-start' type='button' onClick={() => this.runFaceTrain()}>開始特徵提取</button>\n        </div>\n        <Progress completed={this.state.progress} />\n        <div className='train-images'>\n          {this.state.images.map((image, index) => <img className='image' key={`image-${index}`} src={image.url} alt={image.name} />)}\n        </div>\n      </div >\n    );\n  }\n}\n\nexport default withRouter(Train);\n","/* eslint-disable no-useless-escape */\nimport stringify from 'stringify-object';\n\n/**\n* Format user descriptors to export\n* @param {string} name \n* @param {array} datas \n*/\nexport const formatDescriptors = (name = 'Robby Wu', datas = []) => {\n    const descriptors = datas.map(m => stringify(m.join(',')));\n    return JSON\n        .stringify({ name, descriptors })\n        .replace(/\\\"'/g, '\\n    [')\n        .replace(/\\'\"/g, ']')\n        .replace(/\\]]/g, ']\\n]')\n        .replace(/\\\"descriptors\":/g, '\\n  \"descriptors\": ')\n        .replace(/\\\"name\":/g, '\\n  \"name\": ')\n        .replace(/\\]}/g, '  ]\\n}')\n}\n\nexport const downloadObjectAsJson = (exportObj, exportName) => {\n    const dataStr = 'data:text/json;charset=utf-8,' + encodeURIComponent(exportObj);\n    const a = document.createElement('a');\n    a.setAttribute('href', dataStr);\n    a.setAttribute('download', exportName + '.json');\n    document.body.appendChild(a);\n    a.click();\n    a.remove();\n}","import React, { Component } from 'react';\nimport { Route, HashRouter } from 'react-router-dom';\nimport { createBrowserHistory } from 'history';\nimport './App.scss';\n\nimport Home from './routes/Home';\nimport ImageInput from './routes/ImageInput';\nimport VideoInput from './routes/VideoInput';\nimport Train from './routes/Train';\n\nclass App extends Component {\n  render() {\n    return (\n      <div className=\"App\">\n        <HashRouter history={createBrowserHistory({ basename: process.env.PUBLIC_URL })}>\n          <div className=\"route\">\n            <Route exact path=\"/\" component={Home} />\n            <Route exact path=\"/photo\" component={ImageInput} />\n            <Route exact path=\"/camera\" component={VideoInput} />\n            <Route exact path=\"/train\" component={Train} />\n          </div>\n        </HashRouter>\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.scss';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}